#### 字节面试准备 2022/5/29

##### 1. MySQL

B+树索引 (多路平衡搜索树)：非叶子节点存放索引关键字， 叶子节点存放数据记录, ==数据记录通过指针相连== ， 构成一个双向链表， 方便地遍历所有或者某一范围内的数据记录。



***聚簇索引***：将[数据存储](https://cloud.tencent.com/product/cdcs?from=10680)与索引放到了一块，找到索引也就找到了数据

***非聚簇索引***：将数据存储 与 索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因



InnoDB 的 聚簇索引和 非聚簇索引都是通过B+ 树实现的。

- 主键索引：使用主键作为表的聚簇索引。
- 辅助索引：二级索引，也是非聚簇索引，为提高某些查询效率设计。辅助索引的非叶子节存放索引列的关键字，叶子节点存放对应聚簇索引（或者说是主键索引）的主键值。

![](https://github.com/Alexanderisgod/PicBed/blob/main/20220530130440.png?raw==true)



InnoDB B+树存放的数据量： 20 Million， 默认页面的大小为 16K

非叶子节点存放指针的数量 ： 16K/ (6+8) = 16384/14 = 1170条 行记录的==地址==

​	==其中 8字节为主键ID， 6字节的为指针长度==

高度为2 的 B+ 树， 存放的数据记录 ： 1170* （16K/1K）= 18720 条行记录 ==如今大多使用1K空间存放行数据==

高度为3的 B+ 树： 1170* 1170* 16 = 18720* 1170 = 21902400

So  B+树的宽度为 1170

###### 事务隔离级别——只有InnoDB 支持：

![](https://github.com/Alexanderisgod/PicBed/blob/main/20220530140038.png?raw==true)

脏读：读到了其他事务未提交的数据

可重复读：一个事务内，最开始读到的数据和 事务结束前 的任意时刻读到的是数据 一致， 通常为update操作

不可重复读：同一事务内，不同时刻读到的同一批数据不一样

幻读：针对插入 Insert操作，事务A对 某些内容做出修改， 但是还未提交， 事务B插入了 事务A更改前的 记录相同 的记录行， 并在事务A提交之前先提交， 导师A查询发现刚刚的 更改对于某些数据未起作用， 即是幻读。

==读未提交：不加锁==

读提交：一个事务只能读取 其他事务提交之后的数据， 也就是其他事务调用Commit之后的数据。

可重复读：事务不会读到其他事务对已有数据的 修改， 即使其他事务已经提交。

MySQL加锁：

​	读未提交：不加锁

​	串行化：读时候加 共享锁， 事务并发读，但不能并发写。 写的时候加入排他锁， 其他事务不能并发写，也不能并发读。

​	如何实现可重复读：MySQL采用了 MVCC （多版本并发控制）。

![](https://github.com/Alexanderisgod/PicBed/blob/main/20220530151625.png?raw==true)

==可重复读是在事务开始的时候生成一个当前事务全局性的快照==

==读提交则是每次执行语句的时候都重新生成一次快照。==

[解决并发写问题 和 解决幻读问题？？](https://zhuanlan.zhihu.com/p/117476959)

无法解决幻读，只能降低幻读发生的概率。

![](https://github.com/Alexanderisgod/PicBed/blob/main/20220530152133.png?raw==true)

> 这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。

MySQL 的 Hash索引

> ***1.innodb本身的索引结构是B+tree，而hash索引是innodb存储引擎提供的特性功能***
>
>  ***2.innodb存储引擎内部自己去监控索引表，如果监控到某个索引经常用，那么就认为是热数据，然后内部自己创建一个hash索引（只适用“=”的查询，对“in”“<=>”这些范围查询不适用）***
>
>  ***3.创建了hash索引后，如果下次又查询到这个索引，那么直接通过hash算法推导出记录的地址，直接一次就能查到数据，比重复去B+tree索引中查询三四次节点的效率高了不少***



##### 1.1 Redis相关

​		非关系型数据库。

​			redis使用内存提供存储，通过持久化功能保存数据。且针对request是单线程操作。

1. Redis不仅仅只支持简单的K-V形式的数据存储，还支持list、set、hash、zset等等集合类数据的存储；
2. Redis支持实时的数据备份，及时宕机，也可以把数据恢复过来；
3. Redis支持数据的持久化，可以存放在内存memory中的数据直接保存在磁盘上；

​		应用场景：

- 查找最新的回复
- 排名问题，ZRank进行获得
- 删除过期数据：加上有效时间， 超时后自动删除对应的数据

​		Redis的三大问题：

- 击穿：一个Key非常热点， 过期之后，大并发击穿缓存，直接请求数据库，设置永不过期。
- 雪崩：大面积的缓存失效
- 穿透：缓存和数据库都没有数据



##### 2. 操作系统

进程描述符：

- 标识符：进程的唯一标识
- 状态：任务状态，退出代码和退出想好
- 优先级
- 程序计数器：执行到的下一条指令地址
- 内存指针：程序代码和进程相关数据的指针，共享内存块的指针
- 上下文数据：寄存器中的数据——包含堆栈中的内容
- I/O状态：I/O分配，请求和被分配的设备和文件列表

进程通信机制：

- 管道pipe： 半双工的通信方式， 在父子进程间
- named pipe FIFO: 半双工，允许非父子进程通信
- 消息队列 MQ： 消息的链表， 相较于管道：传输的信息更多
- 共享存储：共享内存，最快的IPC方式
- 信号量、套接字和信号

进程切换——上下文切换

- 进程地址空间的切换
- 处理器状态切换

中断异常的处理流程：

​	CPU收到中断 和 异常的信号时，暂停执行当前的任务和程序，跳转到相关处理程序之中，完成后，在跳回来。

1. 事前准备：中段信号编写规则，确定 OS 相关中段处理的程序。
2. CPU检查当前的中段信号， 软中断（中段向量：==硬件产生的中断入口地址或存放中断服务程序的首地址。==）和硬中断。
3. 根据 中断向量 到DT表中 取得处理 这个向量的中断程序和 段选择符。
4. 根据段选择符到 GDT中 找到相应的段描述符。
5. CPU根据 优先级 设定即将运行的 中断服务程序 使用的 栈的地址。
6. 保护当前程序的现场。
7. 跳转到中断服务程序 第一条指令执行
8. 完成中断处理程序， 返回

线程私有——防止脏写和脏读：

- 栈
- 线程局部存储（Thread Local Storage, TLS）, 有限容量。
- 寄存器

线程和进程共享：

- 全局变量
- 堆
- 函数中的静态变量
- 程序代码
- 打开的文件

死锁的产生条件

- 互斥条件
- 不可剥夺
- 环路等待
- 请求并保持

MQ框架： 

- RabbitMQ :

  

- [RocketMQ](https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md):

  阿里参考链接：https://help.aliyun.com/document_detail/29532.html

  削峰填谷

  异步解耦

  顺序收发

  分布式事务一致性

  大数据分析

  分布式缓存同步

  

- Kafka



##### 3. 网络

为什么要TCP三次握手，两次的问题？

​	要保证双方 ==收发== 能力， 两次的话无法保证 发起方的  接受能力。

OSI 七层协议：	

​	应用层，表示层，会话层， 传输层，网络层，数据链路层， 物理层

UDT协议：结合了 TCP和UDP的优点

> ​	基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 
>
> ​	顾名思义，UDT建于UDP之上，并引入==新的拥塞控制和数据可靠性控制机制==。UDT是面==向连接的双向的应用层协议==。它同时支持==可靠的数据流传输和部分可靠的数据报传输==。 由于UDT完全在UDP上实现，它也可以应用在==除了高速数据传输==之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

网页打开的过程 URL--》网页：

- DNS解析
- TCP连接
- HTTP连接
- 服务器处理请求，返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

Http和Https的区别：

- Https在 Http的基础上加入了SSL层， HTTPS的安全基础为 SSL。 HTTPS有一个==加密/身份验证层==(HTTP/TCP)之间。
- HTTPS需要申请CA 证书。
- HTTP的端口为80， HTTPS的端口为443
- http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

SSL加密：

​	对HTTP传输的数据进行加密。

![](https://github.com/Alexanderisgod/PicBed/blob/main/20220601114258.png?raw=true)



TCP的拥塞控制和流量控制：

- 拥塞控制：防止过多的数据流入网络。

- 流量控制：发送者发送数据过快，接受者接收能力不足。避免分组丢失，控制发送速度。

  1. 滑动窗口协议（连续ARQ协议）实现，保证分组无差错、有序接受。
  2. 接收方返回ACK包含自己的接受窗口大小，利用大小控制发送方的数据发送
  3. ==死锁==问题：发送者收到接受窗口 为0 的应答， 但是之后的 接收方的 应答丢失， ==发送者不发报文， 接收方等待==
  4. ==避免死锁== ： 发送者收到零窗口后，启动计时器， expire之后，向接收者询问接收窗口大小。

- 两者区别

  > **拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。**
  >
  > **流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。**

TCP4次挥手：

​			![](https://github.com/Alexanderisgod/PicBed/blob/main/20220601120151.png?raw=true)

- TCP是全双工传输协议，也就是说双方都可进行读写操作，当一方不需要写数据时，会通过发送FIN报文告知对方，我要关闭连接了，对方接受到并返回ACK报文，这就表示一方的连接已经关闭，此时另一方的连接还是OK的，也就是说另一方（==服务端==）还是可以继续写数据的，等到另一方也发完数据之后就可以发送FIN报文。

  ==注：==**接收到FIN报文时系统只能返回一个ACK，它无法发出FIN报文，因此FIN报文的发出是由业务层来触发的**

- **TIME_WAIT**的作用：TIME_WAIT的作用是***保证关闭连接后这个连接在网络中的所有数据包都过期***，==否则==的话可能存在这样的问题，连接关闭了但是网络中还==残留旧连接的报文==，这样如果以同样的TCP 4元组新建的连接可能会接收到该旧报文，会以为是新连接的报文而导致问题。

- ###### **CLOSE_WAIT阶段**(被动端):

  正常情况下CLOSE_WAIT存在的时间很短，因为稍后被动关闭端会发出FIN报文，然后进到 LAST_ACK 状态。如果系统中存在较多的CLOSE_WAIT 状态的连接，说明是本端服务没有处理好，比如：

  1. **本身程序问题**：应用层忘记进行close，或者close不及时，再或者应用没有及时对端发送来的FIN报文响应close动作；
  2. **新建连接太多问题**：比如存在（3次握手中的）已连接队列中的连接未被应用及时accept导致客户端已经close了，此时连接就处于CLOSE_WAIT阶段了

##### 4. 数据结构

红黑树： 一种特别的AVL（平衡二叉树）， 进行插入和删除操作时候，保持二叉查找树的平衡，==保证较高的查找性能== 。查找，插入和删除的时间复杂度为 $O(log\;n)$ .

红黑树性质：

- 每个节点为红或者 黑
- 根节点为黑色
- 每个叶子节点 NIL 为黑
- 每个红色节点的两个子节点一定都是黑色 （红色节点不能连续）
- 任意一节点 到 每个叶子节点的路径  包含相同数量的黑节点。

```C++
// 红黑树左旋和右旋

//左旋
void rotateLeft(Entry<k, v> p){
    if(p!=NULL){
        Entry<k, v> r=p.right;
        // 根节点连接 右树的 左节点
        p->right = r.left;
        if(!r.left) r.left.parent = p;
        
        // 右树的父节点 进行更换
        r.parent= p.parent;
        // p节点是不是 root节点
        if(r.parent==NULL) {
            // p为根节点
            root=r;
        }else if(p.parent.left=p){
            p.parent.left=r;
        }else
            p.parent.right=r;
        
        //断开 p和父节点的连接， 指向 right子树
        p.parent=r;
        r.left=p;
    }
}


```

什么时候左旋和右旋呢？？以及变色的情况？？[==参考链接==](https://blog.csdn.net/jinking01/article/details/106020347)

```java
// 红黑树调整
//红黑树调整函数fixAfterInsertion()
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;
    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {//如果y为null，则视为BLACK
                setColor(parentOf(x), BLACK);              // 情况1
                setColor(y, BLACK);                        // 情况1
                setColor(parentOf(parentOf(x)), RED);      // 情况1
                x = parentOf(parentOf(x));                 // 情况1
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);                       // 情况2
                    rotateLeft(x);                         // 情况2
                }
                setColor(parentOf(x), BLACK);              // 情况3
                setColor(parentOf(parentOf(x)), RED);      // 情况3
                rotateRight(parentOf(parentOf(x)));        // 情况3
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);              // 情况4
                setColor(y, BLACK);                        // 情况4
                setColor(parentOf(parentOf(x)), RED);      // 情况4
                x = parentOf(parentOf(x));                 // 情况4
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);                       // 情况5
                    rotateRight(x);                        // 情况5
                }
                setColor(parentOf(x), BLACK);              // 情况6
                setColor(parentOf(parentOf(x)), RED);      // 情况6
                rotateLeft(parentOf(parentOf(x)));         // 情况6
            }
        }
    }
    root.color = BLACK;
}
```

